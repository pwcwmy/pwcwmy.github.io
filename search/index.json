[{"content":"课题是自动代码修复apr 数据集选择 defects4j-1.2.0 defects4j-2.0.0\n与训练模型 codebert 最新的deepseek也可以试下，代码能力挺好\n算法初步流程\n完美故障定位\n构造输入 这个设计其实比较理想了 bug行、前后文都考虑到了 这里可以多增加一些模版替代\u0026amp;\u0026amp; || ?之类 减少mask\n输入codebert 采用berm_search搜索，这里可以后期探索N=？合适 每个位置生成的补丁临时排序，取前三个\nRe-rank再排序 当bug前后位置不再是mask，再次进行排序 得到对每个可能是bug的补丁\n通过测试套件验证修复\n建立实验基线 使用了两种标准指标，一种是刚刚通过项目整个测试套件的可信补丁，另一种是在语法或语义上等同于开发人员补丁的正确补丁。遵循APR的常用实践，通过手动检查每个可能的补丁来确定正确的补丁是否语义等效。\n建立工具比较基线 可以对比一些基于学习的 基于模版的 基于模型的目前主要就alpharepair\nTODO： 因为用模型做apr的典型大多都是上述这个思路 所以下面有一些想法 可以组合基于模版和基于模型的结果 只要可以提高正确补丁数量 1+1\u0026gt;2\n调berm_search 的N\n在输入时加入提示词工程，优化PE\n要研究或解决的问题\n拟采用的研究手段(途径)\n","date":"2025-01-27T12:45:08+08:00","permalink":"https://pwcwmy.github.io/p/my-repair/","title":"My Repair"},{"content":"88页 sql基础.pdf 6. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 select p_ID, ifnull((select p_Num from MyTable child where child.s_id = 1 and child.p_ID = MyTable.p_ID),0) s1, ifnull((select p_Num from MyTable child where child.s_id = 2 and child.p_ID = MyTable.p_ID),0) s2, ifnull((select p_Num from MyTable child where child.s_id = 3 and child.p_ID = MyTable.p_ID),0) s3 from MyTable GROUP BY p_ID -- 参考方法 select p_ID, sum(case when s_id = 1 then p_Num else 0 end) s1, sum(case when s_id = 2 then p_Num else 0 end) s2, sum(case when s_id = 3 then p_Num else 0 end) s3 from MyTable GROUP BY p_ID 2. 牛客201： 查找入职员工时间排名倒数第三的员工所有信息（入职时间相同的员工可能不止一人） https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c?tpId=82\u0026tqId=29753\u0026rp=1\u0026ru=%2Fexam%2Foj\u0026qru=%2Fexam%2Foj\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\u0026difficulty=undefined\u0026judgeStatus=undefined\u0026tags=\u0026title=\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- 自己写的，时间排名倒数第三，是实际的值在排名，用dense_rank() 而不是rank() select e.* from (select *, dense_rank() over(order by hire_date desc) rk from employees) t, employees e where t.emp_no = e.emp_no and t.rk = 3 -- 题解 SELECT * FROM employees WHERE hire_date = ( SELECT DISTINCT hire_date FROM employees ORDER BY hire_date DESC -- 倒序 LIMIT 1 OFFSET 2 -- 去掉排名倒数第一第二的时间，取倒数第三 ); 3. SQL210 获取所有员工当前的manager https://www.nowcoder.com/practice/e50d92b8673a440ebdf3a517b5b37d62?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=0\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 select t.emp_no, d.emp_no manager from (select emp_no, dept_no from dept_emp where emp_no not in (select emp_no from dept_manager)) t, dept_manager d where t.dept_no = d.dept_no -- 题解 select e.emp_no,m.emp_no from dept_emp as e inner join dept_manager as m on e.dept_no=m.dept_no where e.emp_no!=m.emp_no 4. SQL211 获取每个部门中薪水最高的员工相关信息 https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=0\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 过了2/3 select t.dept_no, sa.emp_no, maxSalary salary from (select dept_no, max(salary) maxSalary from dept_emp, salaries where dept_emp.emp_no = salaries.emp_no group by dept_no) t, salaries sa where t.maxSalary = sa.salary order by t.dept_no 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 题解 SELECT currentsalary.dept_no, currentsalary.emp_no, currentsalary.salary AS salary FROM -- 创建maxsalary表用于存放当前每个部门薪水的最大值 (SELECT d.dept_no, MAX(s.salary) AS salary FROM salaries AS s INNER JOIN dept_emp As d ON d.emp_no = s.emp_no WHERE d.to_date = \u0026#39;9999-01-01\u0026#39; AND s.to_date = \u0026#39;9999-01-01\u0026#39; GROUP BY d.dept_no) AS maxsalary, -- 创建currentsalary表用于存放当前每个部门所有员工的编号和薪水 (SELECT d.dept_no, s.emp_no, s.salary FROM salaries AS s INNER JOIN dept_emp As d ON d.emp_no = s.emp_no WHERE d.to_date = \u0026#39;9999-01-01\u0026#39; AND s.to_date = \u0026#39;9999-01-01\u0026#39; ) AS currentsalary -- 限定条件为两表的dept_no和salary均相等 WHERE currentsalary.dept_no = maxsalary.dept_no AND currentsalary.salary = maxsalary.salary -- 最后以currentsalary.dept_no排序输出符合要求的记录表 ORDER BY currentsalary.dept_no 5. SQL216 获取当前薪水第二多的员工的emp_no以及其对应的薪水salary https://www.nowcoder.com/practice/8d2c290cc4e24403b98ca82ce45d04db?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=0\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 select t.emp_no, t.salary from (select emp_no, salary, dense_rank() over(order by salary desc) rk from salaries) t, salaries s where t.emp_no = s.emp_no and t.rk = 2 -- 更贴题意 SELECT emp_no, salary FROM salaries WHERE salary = (SELECT salary FROM salaries WHERE to_date = \u0026#39;9999-01-01\u0026#39; GROUP BY salary ORDER BY salary DESC LIMIT 1,1 ) 6. SQL220 查找在职员工自入职以来的薪水涨幅情况 https://www.nowcoder.com/practice/fc7344ece7294b9e98401826b94c6ea5?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=0\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 select t1.emp_no, (case when t2.min_salary != 0 then t1.max_salary - t2.min_salary else t1.max_salary end) growth from (select emp_no, max(salary) max_salary from salaries where to_date = \u0026#39;9999-01-01\u0026#39; group by emp_no) t1, -- 这里不严谨，应该用入职工资表 (select emp_no, min(salary) min_salary from salaries where to_date != \u0026#39;9999-01-01\u0026#39; group by emp_no) t2 where t1.emp_no = t2.emp_no order by growth -- 题解 select b.emp_no,(b.salary-a.salary) as growth from (select e.emp_no,s.salary from employees e left join salaries s on e.emp_no=s.emp_no and e.hire_date=s.from_date)a -- 入职工资表 inner join (select e.emp_no,s.salary from employees e left join salaries s on e.emp_no=s.emp_no where s.to_date=\u0026#39;9999-01-01\u0026#39;)b -- 现在工资表 on a.emp_no=b.emp_no order by growth 7. 获取所有非manager员工当前的薪水情况 https://www.nowcoder.com/practice/8fe212a6c71b42de9c15c56ce354bebe?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=0\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 5 6 7 8 9 10 11 12 select dp.dept_no, e.emp_no, s.salary from employees e, dept_emp dp, salaries s where e.emp_no = dp.emp_no and e.emp_no = s.emp_no and e.emp_no not in (select emp_no from dept_manager) 8. SQL217 获取当前薪水第二多的员工的emp_no以及其对应的薪水salary https://www.nowcoder.com/practice/c1472daba75d4635b7f8540b837cc719?tpId=82\u0026tags=\u0026title=\u0026difficulty=\u0026judgeStatus=3\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\u0026gioEnter=menu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 select e.emp_no, t.salary, e.last_name, e.first_name from (select s1.emp_no, s1.salary, (select count(1) from salaries s2 where s2.salary \u0026gt;= s1.salary) rk from salaries s1) t, employees as e where t.emp_no = e.emp_no and t.rk = 2 9. SQL224 获取员工其当前的薪水比其manager当前薪水还高的相关信息 https://www.nowcoder.com/practice/f858d74a030e48da8e0f69e21be63bef?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=3\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 select t.emp_no, t.manager_no, (select salary from salaries where emp_no = t.emp_no) emp_salary, (select salary from salaries where emp_no = t.manager_no) manager_salary from (select dp.emp_no, dr.emp_no manager_no from dept_emp dp, dept_manager dr where dp.dept_no = dr.dept_no and dp.emp_no != dr.emp_no) t where (select salary from salaries where emp_no = t.emp_no) \u0026gt; (select salary from salaries where emp_no = t.manager_no) -- 某个题解· select de.emp_no,dm.emp_no as manager_no, s1.salary as emp_salary,s2.salary as manager_salary from dept_emp de,dept_manager dm,salaries s1,salaries s2 where de.dept_no=dm.dept_no and de.emp_no=s1.emp_no and dm.emp_no=s2.emp_no and s1.salary\u0026gt;s2.salary and s2.to_date=\u0026#39;9999-01-01\u0026#39; and s1.to_date=\u0026#39;9999-01-01\u0026#39;; 10. SQL228 使用join查询方式找出没有分类的电影id以及名称 1 2 3 4 5 6 7 8 9 10 11 -- 内连接+ not in select film_id as \u0026#39;电影id\u0026#39;,title as \u0026#39;名称\u0026#39; from film where film_id not in(select f.film_id from film f inner join film_category fc on f.film_id=fc.film_id) -- 左连接+is null https://www.nowcoder.com/practice/a158fa6e79274ac497832697b4b83658?tpId=82\u0026amp;tags=\u0026amp;title=\u0026amp;difficulty=\u0026amp;judgeStatus=3\u0026amp;rp=1\u0026amp;sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\u0026amp;gioEnter=menu select f.film_id, f.title from film f left join film_category fc on f.film_id=fc.film_id where fc.category_id is null 11. 建表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create table actor( actor_id smallint(5) not null comment \u0026#39;id\u0026#39;, first_name varchar(45) not null comment \u0026#39;名字\u0026#39;, last_name varchar(45) not null comment \u0026#39;姓\u0026#39;, last_update date comment \u0026#39;日期\u0026#39;, primary key(actor_id) ) -- CREATE TABLE IF NOT EXISTS actor ( actor_id smallint(5) NOT NULL PRIMARY KEY, first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL, last_update timestamp NOT NULL DEFAULT (datetime(\u0026#39;now\u0026#39;,\u0026#39;localtime\u0026#39;)) ) 12. 批量插入数据 https://www.nowcoder.com/practice/51c12cea6a97468da149c04b7ecf362e?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=3\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 5 6 INSERT INTO actor(actor_id, first_name, last_name, last_update) VALUES(1,\u0026#39;PENELOPE\u0026#39;,\u0026#39;GUINESS\u0026#39;,\u0026#39;2006-02-15 12:34:33\u0026#39;), (2,\u0026#39;NICK\u0026#39;,\u0026#39;WAHLBERG\u0026#39;,\u0026#39;2006-02-15 12:34:33\u0026#39;); 13. SQL234 批量插入数据，不使用replace操作, 数据已存在，主键冲突 1 2 3 4 5 6 # mysql中常用的三种插入数据的语句: # insert into表示插入数据，数据库会检查主键，如果出现重复会报错； # replace into表示插入替换数据，需求表中有PrimaryKey， # 或者unique索引，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样； # insert ignore表示，如果中已经存在相同的记录，则忽略当前新数据； insert ignore into actor values(\u0026#34;3\u0026#34;,\u0026#34;ED\u0026#34;,\u0026#34;CHASE\u0026#34;,\u0026#34;2006-02-15 12:34:33\u0026#34;); 14. SQL236 对first_name创建唯一索引uniq_idx_firstname https://www.nowcoder.com/practice/e1824daa0c49404aa602cf0cb34bdd75?tpId=82\u0026tags=\u0026title=\u0026difficulty=0\u0026judgeStatus=3\u0026rp=1\u0026sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D82\n1 2 3 4 -- 对first_name创建唯一索引uniq_idx_firstname -- 对last_name创建普通索引idx_lastname create unique index uniq_idx_firstname on actor(first_name); create index idx_lastname on actor(last_name); 15. SQL237 针对actor表创建视图actor_name_view 1 2 3 4 5 6 7 create view actor_name_view as select first_name first_name_v, last_name last_name_v from actor 16. SQL238 针对上面的salaries表emp_no字段创建索引idx_emp_no 1 2 3 4 5 6 7 8 create index idx_emp_no on salaries(emp_no) select * from salaries force index (idx_emp_no) where emp_no=10005 -- 注：force index 要在where条件之前 -- (idx_emp_no)的括号一定不能丢 -- 语法规范：在MySQL中，当使用 FORCE INDEX、USE INDEX 或 IGNORE INDEX 等提示时，索引名称需要放在圆括号内。这是MySQL SQL语法的一部分，旨在明确指出哪些索引应该被考虑或强制使用。 为什么要用强制索引？ 因为MYSQL优化器优化后使用的索引未必是最优的，当优化器指定的索引影响查询速度时用强制索引可以用来提高查询速度。 force index 要在where条件之前 逻辑顺序：在SQL查询的逻辑处理顺序中，首先需要确定从哪个表以及如何访问这些表的数据（包括选择合适的索引）。FORCE INDEX 就是用来指定这种访问方式的。因此，它必须出现在 FROM 孥句中，紧随表名之后。 查询优化器的工作机制：查询优化器在决定如何执行查询计划时，首先会考虑如何访问各个表的数据。通过在 FROM 子句中指定 FORCE INDEX，你是在告诉优化器在访问 salaries 表时强制使用 idx_emp_no 索引。这发生在应用任何过滤条件（如 WHERE 子句）之前。\n17. 在原来的表基础上新增一列 1 2 alter table actor add (create_date datetime not null default \u0026#39;2020-10-01 00:00:00\u0026#39;) 18. 如何开发系统时记录用户不同类型的操作日志（可以思考一下字节广审实践是否是这样做的，大概率不是） 构造一个触发器audit_log，在向employees_test表中插入一条数据的时候，触发插入相关的数据到audit中。 作用:监视某种情况，并触发某种操作 很多人都不提倡使用触发器，因为这是一个隐藏的过程不好管理。 1 2 3 4 5 6 7 create trigger audit_log after insert on employees_test for each row begin insert into audit values(new.id, new.name); -- 后面的分号一定不能丢 end ","date":"2025-01-17T21:54:18+08:00","permalink":"https://pwcwmy.github.io/p/sql-plus-0/","title":"Sql Plus 0"},{"content":"","date":"2025-01-17T18:45:41+08:00","permalink":"https://pwcwmy.github.io/p/linux-150%E9%81%93%E5%BC%80%E8%83%83%E8%8F%9C/","title":"Linux 150道开胃菜"},{"content":"数据准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #–1.学生表 #Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别 CREATE TABLE `Student` ( `s_id` VARCHAR(20), s_name VARCHAR(20) NOT NULL DEFAULT \u0026#39;\u0026#39;, s_brith VARCHAR(20) NOT NULL DEFAULT \u0026#39;\u0026#39;, s_sex VARCHAR(10) NOT NULL DEFAULT \u0026#39;\u0026#39;, PRIMARY KEY(s_id) ); #–2.课程表 #Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号 create table Course( c_id varchar(20), c_name VARCHAR(20) not null DEFAULT \u0026#39;\u0026#39;, t_id VARCHAR(20) NOT NULL, PRIMARY KEY(c_id) ); /* –3.教师表 Teacher(t_id,t_name) –教师编号,教师姓名 */ CREATE TABLE Teacher( t_id VARCHAR(20), t_name VARCHAR(20) NOT NULL DEFAULT \u0026#39;\u0026#39;, PRIMARY KEY(t_id) ); /* –4.成绩表 Score(s_id,c_id,s_score) –学生编号,课程编号,分数 */ Create table Score( s_id VARCHAR(20), c_id VARCHAR(20) not null default \u0026#39;\u0026#39;, s_score INT(3), primary key(`s_id`,`c_id`) ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #--插入学生表测试数据 #(\u0026#39;01\u0026#39; , \u0026#39;赵雷\u0026#39; , \u0026#39;1990-01-01\u0026#39; , \u0026#39;男\u0026#39;) insert into Student values(\u0026#39;01\u0026#39; , \u0026#39;赵雷\u0026#39; , \u0026#39;1990-01-01\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;02\u0026#39; , \u0026#39;钱电\u0026#39; , \u0026#39;1990-12-21\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;03\u0026#39; , \u0026#39;孙风\u0026#39; , \u0026#39;1990-05-20\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;04\u0026#39; , \u0026#39;李云\u0026#39; , \u0026#39;1990-08-06\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;05\u0026#39; , \u0026#39;周梅\u0026#39; , \u0026#39;1991-12-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;06\u0026#39; , \u0026#39;吴兰\u0026#39; , \u0026#39;1992-03-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;07\u0026#39; , \u0026#39;郑竹\u0026#39; , \u0026#39;1989-07-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;08\u0026#39; , \u0026#39;王菊\u0026#39; , \u0026#39;1990-01-20\u0026#39; , \u0026#39;女\u0026#39;); #--课程表测试数据 insert into Course values(\u0026#39;01\u0026#39; , \u0026#39;语文\u0026#39; , \u0026#39;02\u0026#39;); insert into Course values(\u0026#39;02\u0026#39; , \u0026#39;数学\u0026#39; , \u0026#39;01\u0026#39;); insert into Course values(\u0026#39;03\u0026#39; , \u0026#39;英语\u0026#39; , \u0026#39;03\u0026#39;); #--教师表测试数据 insert into Teacher values(\u0026#39;01\u0026#39; , \u0026#39;张三\u0026#39;); insert into Teacher values(\u0026#39;02\u0026#39; , \u0026#39;李四\u0026#39;); insert into Teacher values(\u0026#39;03\u0026#39; , \u0026#39;王五\u0026#39;); #--成绩表测试数据 insert into Score values(\u0026#39;01\u0026#39; , \u0026#39;01\u0026#39; , 80); insert into Score values(\u0026#39;01\u0026#39; , \u0026#39;02\u0026#39; , 90); insert into Score values(\u0026#39;01\u0026#39; , \u0026#39;03\u0026#39; , 99); insert into Score values(\u0026#39;02\u0026#39; , \u0026#39;01\u0026#39; , 70); insert into Score values(\u0026#39;02\u0026#39; , \u0026#39;02\u0026#39; , 60); insert into Score values(\u0026#39;02\u0026#39; , \u0026#39;03\u0026#39; , 80); insert into Score values(\u0026#39;03\u0026#39; , \u0026#39;01\u0026#39; , 80); insert into Score values(\u0026#39;03\u0026#39; , \u0026#39;02\u0026#39; , 80); insert into Score values(\u0026#39;03\u0026#39; , \u0026#39;03\u0026#39; , 80); insert into Score values(\u0026#39;04\u0026#39; , \u0026#39;01\u0026#39; , 50); insert into Score values(\u0026#39;04\u0026#39; , \u0026#39;02\u0026#39; , 30); insert into Score values(\u0026#39;04\u0026#39; , \u0026#39;03\u0026#39; , 20); insert into Score values(\u0026#39;05\u0026#39; , \u0026#39;01\u0026#39; , 76); insert into Score values(\u0026#39;05\u0026#39; , \u0026#39;02\u0026#39; , 87); insert into Score values(\u0026#39;06\u0026#39; , \u0026#39;01\u0026#39; , 31); insert into Score values(\u0026#39;06\u0026#39; , \u0026#39;03\u0026#39; , 34); insert into Score values(\u0026#39;07\u0026#39; , \u0026#39;02\u0026#39; , 89); insert into Score values(\u0026#39;07\u0026#39; , \u0026#39;03\u0026#39; , 98); 1. 查询01课程比02课程高的学生的信息及课程分数 法一：使用自连接\n1 2 3 4 5 6 7 8 9 10 SELECT c.*, a.s_score s01, b.s_score s02 from Score a, Score b, Student c WHERE a.s_id = b.s_id and a.c_id = \u0026#39;01\u0026#39; and b.c_id = \u0026#39;02\u0026#39; and a.s_score \u0026gt; b.s_score and a.s_id = c.s_id 法二：把长型数据变成宽型数据 max(case when a.c_id = \u0026lsquo;02\u0026rsquo; then a.s_score end) s02\n1 2 3 4 5 6 7 8 9 10 11 12 SELECT c.*, t.s01, t.s02 FROM (SELECT a.s_id, max(CASE WHEN a.c_id = \u0026#39;01\u0026#39; then a.s_score end) s01, max(CASE WHEN a.c_id = \u0026#39;02\u0026#39; then a.s_score end) s02 FROM Score a GROUP BY a.s_id) t, Student c where t.s01 \u0026gt; t.s02 and t.s_id = c.s_id 2. 查询01课程比02课程高的学生的信息及课程分数 1 2 3 4 5 6 7 8 9 10 11 12 SELECT c.*, t.s01, t.s02 FROM (SELECT a.s_id, max(CASE WHEN a.c_id = \u0026#39;01\u0026#39; then a.s_score end) s01, max(CASE WHEN a.c_id = \u0026#39;02\u0026#39; then a.s_score end) s02 FROM Score a GROUP BY a.s_id) t, Student c where t.s01 \u0026lt; t.s02 and t.s_id = c.s_id 3. 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩 1 2 3 4 5 6 7 8 9 10 11 12 -- Score avg() group s_id Student -- 查s_name 可以用子查询或者两表连接 SELECT a.s_id, b.s_name s_name, avg(a.s_score) avg_s FROM Score a join Student b on a.s_id = b.s_id GROUP BY a.s_id HAVING avg(a.s_score) \u0026gt;= 60 4. 查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩 这里有陷阱：08号同学没有参加考试， 所以一定要用外连接 right join Student\n1 2 3 4 5 6 7 8 9 10 11 12 -- Score avg() group s_id Student -- 查s_name 可以用子查询或者两表连接 SELECT b.s_id, b.s_name s_name, ifnull(avg(a.s_score),0) avg_s FROM Score a RIGHT JOIN Student b on a.s_id = b.s_id GROUP BY b.s_id HAVING ifnull(avg(a.s_score),0) \u0026lt; 60 5. 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩（包括有成绩和无成绩的） 这里有陷阱：08号同学没有参加考试， 所以一定要用外连接 right join Student, 同时统计sum时要ifnull(sum, 0)\n1 2 3 4 5 6 7 8 9 SELECT c.s_id, c.s_name, COUNT(a.c_id) cnt, ifnull(SUM(a.s_score), 0) sum FROM Score a right join Student c on a.s_id = c.s_id GROUP BY c.s_id 6. 查询\u0026quot;李\u0026quot;姓老师的数量 1 2 3 4 5 SELECT count(*) cnt FROM Teacher a WHERE a.t_name like \u0026#34;李%\u0026#34; 7. 查询学过\u0026quot;张三\u0026quot;老师授课同学的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -- 自己写的 SELECT * FROM Student WHERE Student.s_id in (SELECT sc.s_id FROM (SELECT c.c_id FROM Course c join Teacher t on c.t_id = t.t_id where t.t_name = \u0026#34;张三\u0026#34;) tmp, Score sc where tmp.c_id = sc.c_id) --参考 SELECT c.* FROM Course a, Score b, Student c, Teacher d WHERE a.c_id = b.c_id and c.s_id = b.s_id and a.t_id = d.t_id and d.t_name = \u0026#34;张三\u0026#34; 8. 查询没学过\u0026quot;张三\u0026quot;老师授课同学的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 -- 自己写的 SELECT * FROM Student WHERE Student.s_id not in (SELECT sc.s_id FROM (SELECT c.c_id FROM Course c join Teacher t on c.t_id = t.t_id where t.t_name = \u0026#34;张三\u0026#34;) tmp, Score sc where tmp.c_id = sc.c_id) -- 参考 not in SELECT * FROM Student where s_id not in (SELECT b.s_id FROM Course a, Score b, Teacher d WHERE a.c_id = b.c_id and a.t_id = d.t_id and d.t_name = \u0026#34;张三\u0026#34;) -- not exists 比 not in 查询效率高 SELECT * FROM Student where not EXISTS (SELECT 1 FROM (SELECT b.s_id FROM Course a, Score b, Teacher d WHERE a.c_id = b.c_id and a.t_id = d.t_id and d.t_name = \u0026#34;张三\u0026#34;) t where Student.s_id = t.s_id) 9. 查询学过01课程也学过02课程的同学信息 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 用长表转宽表的思路，这里比用自然连接的可扩展性好 SELECT s.* FROM (SELECT a.s_id, max(case when a.c_id =\u0026#39;01\u0026#39; then a.c_id end) c01, max(case when a.c_id =\u0026#39;02\u0026#39; then a.c_id end) c02 FROM Score a GROUP BY a.s_id) t, Student s where t.s_id = s.s_id and t.c01 is not NULL and t.c02 is not null 10. 查询学过01课程但没学过02课程的同学信息 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 这里只能用长表转宽表的思路 SELECT s.* FROM (SELECT a.s_id, max(case when a.c_id =\u0026#39;01\u0026#39; then a.c_id end) c01, max(case when a.c_id =\u0026#39;02\u0026#39; then a.c_id end) c02 FROM Score a GROUP BY a.s_id) t, Student s where t.s_id = s.s_id and t.c01 is not NULL and t.c02 is not null 11. 查询没有学全所有课程的同学的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 -- 自己写的 SELECT * FROM Student where s_id not in (SELECT s_id FROM (SELECT a.s_id, max(case when a.c_id = \u0026#39;01\u0026#39; then a.c_id end) c01, max(case when a.c_id = \u0026#39;02\u0026#39; then a.c_id end) c02, max(case when a.c_id = \u0026#39;03\u0026#39; then a.c_id end) c03 FROM Score a GROUP BY a.s_id) t where t.c01 is not NULL and t.c02 is NOT NULL and t.c03 is NOT NULL) -- 参考 思路：学生学的课程数量\u0026lt;课程总数 SELECT a.*, count(b.c_id) cnt FROM Student a left join Score b on a.s_id = b.s_id GROUP BY a.s_id HAVING count(b.c_id) \u0026lt; (SELECT count(c_id) FROM Course) 12.查询至少有一门课与学号01同学所学相同的同学的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- distinct 为了去重 SELECT distinct a.* FROM Student a left JOIN Score b on a.s_id = b.s_id where b.c_id in (SELECT c_id from Score WHERE s_id = \u0026#39;01\u0026#39;) -- 或者用group by 1,2,3,4 -- 这里 1, 2, 3, 4 分别对应 SELECT 语句中的前三列 (column1, column2, column3, column4)。 SELECT a.* FROM Student a left JOIN Score b on a.s_id = b.s_id where b.c_id in (SELECT c_id from Score WHERE s_id = \u0026#39;01\u0026#39;) GROUP BY 1,2,3,4 13.查询与学号01同学所学完全相同的同学的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 -- 思路：构建临时表，假设每个学生都学的和01相同，再把真实学的拼在最右侧, 这里直接拼就好，不用join -- SELECT*FROM Student a,(SELECT c_id FROM Score WHERE s_id=\u0026#39;01\u0026#39;) b -- 找到不匹配的学生id -- 从整体中剔除 -- 临时表 需要full join(mysql不支持） -- 只能left join union right join CREATE table s01_s_temp as (SELECT t.*, s.c_id real_c_id FROM (SELECT*FROM Student a,( SELECT c_id FROM Score WHERE s_id=\u0026#39;01\u0026#39;) b) t left join Score s on t.s_id = s.s_id and t.c_id = s.c_id UNION SELECT t.*, s.c_id real_c_id FROM (SELECT*FROM Student a,( SELECT c_id FROM Score WHERE s_id=\u0026#39;01\u0026#39;) b) t right join Score s on t.s_id = s.s_id and t.c_id = s.c_id); -- 从临时表获取到最终答案 SELECT * FROM Student where s_id not in( SELECT s_id from s01_s_temp where s01_s_temp.c_id is NULL or s01_s_temp.real_c_id is NULL) 14. 查询没学过\u0026quot;张三\u0026quot;老师教授的任一门课程的学生姓名 1 2 3 4 5 6 7 8 9 10 11 SELECT a.s_name FROM Student a where a.s_id not in (SELECT s.s_id FROM Student s join Score sc on s.s_id = sc.s_id where sc.c_id in ( select c_id FROM Teacher t, Course c where t.t_id = c.t_id and t_name = \u0026#34;张三\u0026#34;)) 15. 查询两门及其以上不及格课程的同学的学号,姓名及其平均成绩 1 2 3 4 5 6 7 8 9 10 -- 查询两门及其以上不及格课程的同学的学号、姓名及其平均成绩 select sc.s_id, s.s_name, avg(sc.s_score) avg_s -- count(case when sc.s_score \u0026lt; 60 then 1 end) cnt from Score sc, Student s where sc.s_id = s.s_id GROUP BY sc.s_id HAVING count(case when sc.s_score \u0026lt; 60 then 1 end) \u0026gt;= 2 16. 检索01课程分数小于60， 按分数降序排序的学生信息 1 2 3 4 5 6 7 8 9 10 -- 检索01课程分数小于60， 按分数降序排序的学生信息 SELECT s.* FROM Score sc JOIN Student s on sc.s_id = s.s_id where sc.c_id = \u0026#39;01\u0026#39; and sc.s_score \u0026lt; 60 order by sc.s_score DESC 17. 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 1 2 3 4 5 6 7 8 9 10 11 -- 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 SELECT sc.s_id, max(case when sc.c_id = \u0026#39;01\u0026#39; then sc.s_score end) sc01, max(case when sc.c_id = \u0026#39;02\u0026#39; then sc.s_score end) sc02, max(case when sc.c_id = \u0026#39;03\u0026#39; then sc.s_score end) sc03, avg(sc.s_score) avg_s from Score sc GROUP BY sc.s_id ORDER BY avg(sc.s_score) desc 1 2 3 4 5 6 7 8 9 10 11 12 13 SELECT sc2.*, t.avg_s from Score sc2 left join (SELECT sc.s_id, ROUND(AVG(sc.s_score), 2) avg_s FROM Score sc GROUP BY sc.s_id ORDER BY AVG(sc.s_score) desc ) t on t.s_id = sc2.s_id 18. 查询各科成绩最高分、最低分和平均分: 以如下形式显示: 课程ID, 课程name, 最高分, 最低分，平均分, 及格率，中等率， 优良率， 优秀率 及格 \u0026gt;= 60 中等 70-80 优良 80-90 优秀 \u0026gt;= 90 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -- 查询各科成绩最高分、最低分和平均分: 以如下形式显示: -- 课程ID, 课程name, 最高分, 最低分，平均分, 及格率，中等率， 优良率， 优秀率 -- 及格 \u0026gt;= 60 jg -- 中等 70-80 zd -- 优良 80-90 yl -- 优秀 \u0026gt;= 90 yx -- SELECT c_id, c_name -- FROM -- Course -- 最高分 select sc.c_id, c.c_name, max(sc.s_score) max_sc, min(sc.s_score) min_sc, avg(sc.s_score) avg_sc, count(case when sc.s_score \u0026gt;= 60 then 1 end)/count(1) jg, count(case when sc.s_score \u0026gt;= 70 and sc.s_score \u0026lt; 80 then 1 end)/count(1) zd, count(case when sc.s_score \u0026gt;= 80 and sc.s_score \u0026lt; 90 then 1 end)/count(1) yl, count(case when sc.s_score \u0026gt;= 90 then 1 end)/count(1) yx from Score sc join Course c on sc.c_id = c.c_id group by sc.c_id 19. 按各科成绩进行排序并显示排名（实现不完全） 开窗函数 MySQL 8.0 以后才支持\nrank() 1 1 3 并列1后第3 dense_rank() 1 1 2 并列1后第2 , 用 distinct s_score 后面判断是 \u0026gt;= row_number() 1 2 3 4 5 6 只看是第几行， 不考虑并列 如果是老版本，就要思考用子查询来代替开窗函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 按各科成绩进行排序 -- 开窗函数 SELECT sc.*, RANK() over(PARTITION by c_id ORDER BY c_id, s_score desc) rk FROM Score sc -- 子查询 SELECT sc.*, (select count(1) FROM Score sc2 WHERE sc2.c_id = sc.c_id and sc2.s_score \u0026gt; sc.s_score)+1 rk FROM Score sc order by c_id, s_score desc 20. 查询学生的总成绩并进行排名 注意一定要使用英文的()\n1 2 3 4 5 6 7 8 9 10 11 -- 查询学生的总成绩并进行排名(最好显示下) SELECT t.*, RANK() over(ORDER BY t.sum_sc desc) rk FROM (SELECT sc.s_id, sum(sc.s_score) sum_sc FROM Score sc group by s_id) t 21. 查询不同老师所教不同课程平均分从高到低显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 查询不同老师所教不同课程平均分从高到低显示 -- 言外之意就是 group by 不同老师, 不同课程 SELECT t.t_name, c.c_name, avg(s.s_score) avg_sc FROM Teacher t, Course c, Score s where t.t_id = c.t_id and c.c_id = s.c_id GROUP BY t.t_name, c.c_name ORDER BY avg_sc desc 22. 查询所有课程的成绩第2名到第3名的学生信息及该课程成绩 1 2 3 4 5 6 7 8 9 10 11 12 -- 查询所有课程的成绩第2名到第3名的学生信息及该课程成绩 select s.*, t.s_score from (SELECT sc.*, rank() over(order by sc.s_score desc) rk FROM Score sc) t, Student s where t.s_id = s.s_id and t.rk in (2, 3) 23. 统计各科成绩各分数段人数：课程编号，课程名称，[100-85] [85-70] [70-60] [60-0] 所占百分比 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 统计各科成绩各分数段人数：课程编号，课程名称，[100-85] [85-70] [70-60] [60-0] 所占百分比 SELECT c.c_id, c.c_name, count(case when s_score \u0026gt; 85 and s_score \u0026lt;= 100 then 1 end)/count(1) per1, count(case when s_score \u0026gt; 70 and s_score \u0026lt;= 85 then 1 end)/count(1) per2, count(case when s_score \u0026gt; 60 and s_score \u0026lt;= 70 then 1 end)/count(1) per3, count(case when s_score \u0026gt; 0 and s_score \u0026lt;= 60 then 1 end)/count(1) per4 FROM Course c, Score sc where c.c_id = sc.c_id GROUP BY c.c_id 24. 查询学生平均成绩及其名次 1 2 3 4 5 6 7 -- 查询学生平均成绩及其名次 SELECT s_id, avg(s_score) avg_sc, rank() over(ORDER BY avg(s_score) desc) rk from Score GROUP BY s_id 25. 查询各科成绩前三名的记录 GROUP BY 和聚合函数： 在标准 SQL 中，GROUP BY 通常与聚合函数（如 SUM()、COUNT() 等）一起使用，以对每一组数据进行汇总计算。而你想要的是获取每组中的多条记录（即每个科目下的前三名），而不是对它们进行汇总。 LIMIT 的作用范围： LIMIT 只影响整个查询结果集的行数，而不是针对每个分组的结果。因此，直接在查询末尾加上 LIMIT 3 只会返回前三个全局记录，而不是每个科目下的前三个记录。 缺少窗口函数或子查询逻辑： 为了实现每个科目下的排名并选择前三名，你需要使用窗口函数（如 ROW_NUMBER() 或 RANK()）或者通过子查询来处理每个科目的成绩排名。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT s.s_id, s.s_name, t.c_id, t.s_score, t.rk from (select sc.*, rank() over(PARTITION by sc.c_id ORDER BY sc.s_score desc) rk from Score sc) t, Student s where t.s_id = s.s_id and t.rk \u0026lt;= 3 26. 查询每门课被选修的学生总数 1 2 3 4 5 6 -- 查询每门课被选修的学生总数 select c_id, count(1) from Score GROUP BY c_id 27. 查询出只有两门课程的全部学生的学号和姓名 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 查询出只有两门课程的全部学生的学号和姓名 SELECT s.s_id, s.s_name FROM (select count(1) cnt, sc.s_id from Score sc GROUP BY sc.s_id) t, Student s where t.s_id = s.s_id and t.cnt = 2 28. 查询男生、女生人数 1 2 3 4 5 6 -- 查询男生、女生人数 SELECT count(case when s_sex = \u0026#39;男\u0026#39; then 1 end) male_cnt, count(case when s_sex = \u0026#39;女\u0026#39; then 1 end) female_cnt FROM Student 或者更简洁的方法——直接将男女分组，统计每组个数\n1 2 3 4 SELECT s_sex, count(s_id) cnt from Student GROUP BY s_sex 29. 查询名字中带有\u0026quot;风\u0026quot;字的学生信息 1 2 3 4 5 6 SELECT * FROM Student where s_name like \u0026#34;%风%\u0026#34; 30. 查询同名同性学生名单,并统计同名人数 言外之意：GROUP BY s_name, s_sex\n1 2 3 4 5 6 7 8 SELECT s_name, s_sex, count(s_name) cnt from Student GROUP BY s_name, s_sex HAVING cnt \u0026gt; 1 结论： 经查询，不存在同名同性\n31. 查询1990年出生的学生名单 1 2 3 4 5 6 7 -- 查询1990年出生的学生名单 SELECT * FROM Student WHERE year(s_brith) = 1990 32. 查询每门课程的平均成绩,结果按平均成绩降序排列,平均成绩相同时,按课程编号升序排列 1 2 3 4 5 6 7 8 9 -- 查询每门课程的平均成绩,结果按平均成绩降序排列 -- 平均成绩相同时,按课程编号升序排列 SELECT c_id, avg(s_score) avg_sc from Score GROUP BY c_id ORDER BY avg_sc desc, c_id asc 33. 查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩 SELECT s.s_id, s.s_name, t.avg_sc from (select sc.s_id, ifnull(avg(sc.s_score),0) avg_sc from Score sc GROUP BY sc.s_id) t, Student s where t.s_id = s.s_id and t.avg_sc \u0026gt; 85 34. 查询课程名称为\u0026quot;数学\u0026quot;,且分数低于60的学生姓名和分数 1 2 3 4 5 6 7 8 9 10 -- 查询课程名称为\u0026#34;数学\u0026#34;,且分数低于60的学生姓名和分数 SELECT s.s_name, sc.s_score FROM Course c, Score sc, Student s where c.c_id = sc.c_id and s.s_id = sc.s_id and c.c_name = \u0026#39;数学\u0026#39; and sc.s_score \u0026lt; 60 35. 查询所有学生的课程及分数情况 1 2 3 4 5 6 7 8 9 10 -- 查询所有学生的课程及分数情况 -- 言外之意：s_name, c_name, s_score SELECT s_name, c_name, s_score FROM Student s, Course c, Score sc where s.s_id = sc.s_id and c.c_id = sc.c_id 36. 查询每一门课程成绩都在70分以上的姓名、课程名称和分数 这里可能会错误的理解为 SELECT s.s_name, c.c_name, sc.s_score FROM Score sc, Student s, Course c where sc.s_score \u0026gt;= 70 and sc.s_id = s.s_id and sc.c_id = c.c_id 实际上应该是找到一个学生，所有课程都大于等于70，也就是min(s_score) \u0026gt;= 70\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- 查询每一门课程成绩都在70分以上的姓名、课程名称和分数 SELECT s.s_name, c.c_name, sc.s_score from Student s, Course c, Score sc where s.s_id = sc.s_id and c.c_id = sc.c_id and s.s_id in (SELECT s_id from Score GROUP BY s_id HAVING min(s_score) \u0026gt;= 70) 37. 查询不及格的课程 1 2 3 4 5 6 7 8 -- 查询不及格的课程 SELECT s_name, c_name, s_score from Score sc, Course c, Student s where s_score \u0026lt; 60 and sc.s_id = s.s_id and sc.c_id = c.c_id 38. 查询课程编号为01且课程成绩在80分以上的学生的学号和姓名 1 2 3 4 5 6 7 8 9 10 11 12 -- 查询课程编号为01且课程成绩在80分以上的学生的学号和姓名 SELECT s.s_id, s.s_name from (SELECT sc.s_id FROM Score sc where sc.c_id = \u0026#39;01\u0026#39; and sc.s_score \u0026gt;= 80) t, Student s where t.s_id = s.s_id 39. 求每门课程的学生人数 1 2 3 4 5 6 7 8 -- 求每门课程的学生人数 SELECT c_name, count(1) cnt from Score sc, Course c where sc.c_id = c.c_id GROUP BY sc.c_id 40. 查询选修\u0026quot;张三\u0026quot;老师所授课程的学生中,成绩最高的学生信息及其成绩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- 查询选修\u0026#34;张三\u0026#34;老师所授课程的学生中,成绩最高的学生信息及其成绩 SELECT s.*, sc.s_score FROM Teacher t, Course c, Score sc, Student s where t.t_id = c.t_id and c.c_id = sc.c_id and sc.s_id = s.s_id and t.t_name = \u0026#39;张三\u0026#39; ORDER BY sc.s_score desc LIMIT 1 41. 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 1 2 3 4 5 6 7 -- 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 SELECT distinct a.* from Score a, Score b where a.c_id != b.c_id and a.s_score = b.s_score 42. 查询每门功课成绩最好的前两名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- 查询每门功课成绩最好的前两名 -- 每门功课 不能用limit -- 开窗rank不合适，用row_number SELECT s_name, c_name, s_score, rk from (SELECT s_id, c_id, s_score, ROW_NUMBER() over(PARTITION by c_id ORDER BY s_score desc) rk from Score) t, Student s, Course c where t.s_id = s.s_id and t.c_id = c.c_id and rk \u0026lt;= 2 43.统计每门课程的学生选修人数(超过5人的课程才统计)。要求输出课程号和选修人数,查询结果按人数降序排列, 若人数相同,按课程号升序排列 1 2 3 4 5 6 7 8 9 10 -- 统计每门课程的学生选修人数(超过5人的课程才统计)。 -- 要求输出课程号c_id和选修人数cnt,查询结果按人数降序排列, -- 若人数相同,按课程号升序排列 SELECT sc.c_id, count(1) cnt from Score sc GROUP BY c_id HAVING count(1) \u0026gt; 5 order by cnt desc, c_id asc 44. 检索至少选修两门课程的学生学号 1 2 3 4 5 6 7 -- 检索至少选修两门课程的学生学号 SELECT s_id from Score GROUP BY s_id HAVING count(1) \u0026gt;= 2 45. 查询选修了全部课程的学生信息 1 2 3 4 5 6 7 8 9 10 -- 查询选修了全部课程的学生信息 SELECT s.* from Student s, Score sc where s.s_id = sc.s_id GROUP BY sc.s_id HAVING count(1) = (SELECT count(distinct c_id) from Course) 时间函数专题 select now() 返回当前时间 select year(now()) 当前年份 select month(now()) 当前月份 select day(now()) 是当月的第几天 1月17日 返回17 select dayofyear(now()) 今年第几天 select weekofyear(now()) 今年第几周 select date_format(now(), \u0026lsquo;%m%d\u0026rsquo;) 日期格式化, 函数两个参数逗号分隔 select str_to_date(\u0026lsquo;250115\u0026rsquo;, \u0026lsquo;%y%m%d\u0026rsquo;) 字符串转日期, 函数两个参数逗号分隔 46. 查询各学生的年龄 1 2 3 4 5 6 -- 查询各学生的年龄 SELECT s.*, year(NOW()) - year(s_brith) age from Student s 47. 查询本周过生日的学生 1 2 3 4 5 6 -- 查询本周过生日的学生 SELECT * from Student where week(s_brith) = week(now()) 48. 查询下周过生日的学生 1 2 3 4 5 SELECT * from Student where week(s_brith) = week(now())+1 49. 查询本月过生日的学生 1 2 3 4 5 SELECT * from Student where month(s_brith) = month(now()) 50. 查询下月过生日的学生 1 2 3 4 5 SELECT * from Student where month(s_brith) = month(now())+1 ","date":"2025-01-15T20:35:40+08:00","permalink":"https://pwcwmy.github.io/p/sql-%E5%AE%9E%E6%88%98%E8%BF%9B%E9%98%B650%E8%AE%B2/","title":"Sql 实战进阶50讲"},{"content":"一、一个程序员如何独立负责一个完整项目的过程，从需求的产生到项目的设计和实施，以及对团队成员的责任和对接。 程序员被上级分配了一个完整的项目 需求评估后，项目会立项，有排期后才会到负责人手中 接手项目后，要进行设计讨论阶段，考虑大方向和细节，需要进行调研和技术选择 二、作为项目负责人需要对项目中各个组件和客户端进行编写和设计，包括架构、API、异常处理等，以保证项目正常运作。 需要通过调研和编写组件客户端来证明项目可行性 需要提前设计和搭建服务架构，让其他人专注于业务编写 需要提前设计和确认项目中统一处理的异常和错误码，以及过滤器和拦截器的作用 三、软件开发过程中的一些重要问题，如对业务的理解要一致、注意代码结构和抽象、开发和测试要对齐等。 理解业务一致（对业务字段和状态语义理解高度相同），否则程序编码麻烦 开发环节不重要，但要注意代码结构和抽象 开发后需要部署，但不是正式部署，要和上级沟通避免问题 四、在测试环境中部署时需要进行的确认工作，包括端口、URL、安装步骤、环境配置、脚本、库等方面的细节管理，以确保功能的正常使用。 测试环境的部署不需要自己做，有运维人员处理。 NGINX的端口和URL要正确，网络转发可能有问题。 确认组件之间的网络关系和物理结构，配置要细致管理。（比如docker compose / 运维脚本 / 安装脚本） 五、一个人独立负责一个项目的过程，包括设计、联调、评审、体测、性能测试和上线等阶段，以及需要注意的事项。 项目决定后部署测试环境，联调过程中进行细节修改 设计阶段需要方向大，逐渐开发中可能发生变化 通过评审和性能测试后上线，进行维护和新需求开发（devops） 六、单独对设计阶段进行重点攻关：接口设计、模型设计、对象设计、部署图、关键业务时序图、特别复杂的要有状态图。开发框架，冒烟用例。 首先，介绍下我对细节的理解。细节是具体到方法体内的代码的编写，或者说具体的算法。 工期的预估，分开基本curd接口和复杂接口，根据实力估计多长时间可做完。 设计阶段，得简单的想想细节如何做，才能设计好。 只有设计完成后，才能开始写代码，不然拒绝启动代码编写。 设计，需要做些什么？就是概要设计和详细设计那些，但可以选择不去设计到类。一些业务时序可以省掉，只做关键的，不关键的，可以口述。 具体设计，可以自己用需求用例梳理交互，最终做出接口设计（需求用例就不用放到设计文档中，自己看就好），数据库模型，redis key 读 写 更新规则，mq 生产 消费，elasticsearch 索引设计，对象关系，关键业务时序，部署图，开发框架搭建。 接口 数据库模型 对象关系 这3个一般最先做一版，接口和模型谁先谁后 关系不大，对象关系会靠后点。然后是关键业务时序，复杂点的逻辑可能还需要先来个 状态图。部署图。 接口、模型、对象、部署图 这几个静态图，配合 状态图、关键业务时序图 这几个动态图，动静结合 + 具体实现的想象，互相磨合 改来改去 ，最终出设计结果。 也就是最终设计的文档包含，接口设计、模型设计、对象设计、部署图、关键业务时序图、特别复杂的要有状态图。开发框架。7个东西。5天内搞定。成熟度更好点的团队，可以出点冒烟用例，方便编写完代码后的自测。也就是8个东西 需要设计阶段搞出来。 其中时序图和状态图 根据团队情况 选择哪些出图，哪些只需要口述。\n设计阶段那8个 根据团队的成员实力，可能出不全。那就降低质量，比如接口设计、模型 一定要先保证，但因为没有动态图的思考，有很大概率会导致后续实现时 会改变接口、模型的设计，这是风险点。 还有很多代码实现完，再考虑部署环境，那么 也会有修改代码算法，甚至需要修改接口 模型 这些设计的情况。这样工期就更难保证。 总之，都想好后，再编写代码算法，是最好的方式。关键是如何想好，如何确定已经想好了。\n","date":"2025-01-14T23:55:14+08:00","image":"https://pwcwmy.github.io/p/%E5%A6%82%E4%BD%95%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E8%B4%9F%E8%B4%A3%E9%A1%B9%E7%9B%AE/index_hu6475225103924681404.jpg","permalink":"https://pwcwmy.github.io/p/%E5%A6%82%E4%BD%95%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E8%B4%9F%E8%B4%A3%E9%A1%B9%E7%9B%AE/","title":"如何一个人独立负责项目"},{"content":"","date":"2025-01-14T21:44:37+08:00","permalink":"https://pwcwmy.github.io/p/lawyer-pan/","title":"Lawyer Pan"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://pwcwmy.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://pwcwmy.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://pwcwmy.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://pwcwmy.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://pwcwmy.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://pwcwmy.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://pwcwmy.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://pwcwmy.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://pwcwmy.github.io/p/emoji-support/","title":"Emoji Support"}]